# JS中异步调用的实现方式
## 一、Javascript实现异步编程的过程以及原理
### 1、为什么要用Javascript异步编程
众所周知，Javascript是单线程，单线程即任务是串行的，后一个任务需要等待前一个任务的执行，这就可能出现长时间的等待。但由于类似ajax网络请求、setTimeout时间延迟、DOM事件的用户交互等，这些任务并不消耗 CPU，是一种空等，资源浪费，因此出现了异步。通过将任务交给相应的异步模块去处理，主线程的效率大大提升，可以并行的去处理其他的操作。当异步处理完成，主线程空闲时，主线程读取相应的callback，进行后续的操作，最大程度的利用CPU。此时出现了同步执行和异步执行的概念，同步执行是主线程按照顺序，串行执行任务；异步执行就是cpu跳过等待，先处理后续的任务（CPU与网络模块、timer等并行进行任务）。由此产生了任务队列与事件循环，来协调主线程与异步模块之间的工作。

### 2、Javascript的任务队列和事件循环机制
<img src="https://images2015.cnblogs.com/blog/1094893/201704/1094893-20170419140631852-1337804828.png"/>
* 如上图为事件循环示例图（或JS运行机制图），流程如下：  
> step1：主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈；  
> step2:  主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）;   
> step3:  异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列；    
> step4: 主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）；    
> step5: 重复执行step2、3、4；称为事件循环。    
* 执行的大意：    
> 同步环境执行(step1) -> 事件循环1(step4) -> 事件循环2(step4的重复)…    
* 其中的异步进程有：    
> a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；    
> b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；     
> c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。     
 
```ruby
let syncMethed = () => {
    console.log('我是同步任务1')
    setTimeout(() => {
        console.log('我是异步任务1')
    }, 3000)
    setTimeout(() => {
        console.log('我是异步任务2')
    }, 200)
    setTimeout(() => {
        console.log('我是异步任务3')
    }, 0)
    console.log('我是同步任务2')
}

syncMethed()
